#!/usr/bin/env node
/**
 * StudioFlow — Build Figma Plugin
 *
 * Reads project tokens, workflow config, and page content,
 * then generates figma-plugins/studioflow-screens/code.js
 * by embedding the payload + appending the generic renderer.
 *
 * Usage: node scripts/build-figma-plugin.mjs
 */
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, "..");

// ── Read inputs ────────────────────────────────────────────────────────────────
const workflow = JSON.parse(fs.readFileSync(path.join(ROOT, "studioflow.workflow.json"), "utf8"));
const tokenJson = JSON.parse(fs.readFileSync(path.join(ROOT, "tokens/figma-variables.json"), "utf8"));
const pageContent = JSON.parse(fs.readFileSync(path.join(ROOT, "handoff/figma-page-content.json"), "utf8"));

// ── Flatten tokens ─────────────────────────────────────────────────────────────
function flattenTokens(obj, prefix) {
  const result = [];
  for (const key in obj) {
    const child = obj[key];
    const name = prefix ? prefix + "-" + key : key;
    if (child && typeof child === "object" && "value" in child) {
      result.push({ name, value: child.value });
    } else if (child && typeof child === "object") {
      result.push(...flattenTokens(child, name));
    }
  }
  return result;
}

function groupTokenFrame(tokenName, tokenFrames) {
  const prefix = tokenName.split("-")[0];
  const match = tokenFrames.find((f) => f.prefixes.includes(prefix));
  return match ? match.name : tokenFrames[tokenFrames.length - 1]?.name || "Tokens / Spacing";
}

const flatTokens = flattenTokens(tokenJson).map((t) => ({
  ...t,
  frame: groupTokenFrame(t.name, workflow.tokenFrames),
}));

// ── Extract colors from color.brand.* ──────────────────────────────────────────
function extractColors(tokenJson) {
  const brand = tokenJson?.color?.brand;
  if (!brand) return {};
  const colors = {};
  for (const key in brand) {
    const camelKey = key.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    colors[camelKey] = brand[key].value;
  }
  return colors;
}

const colors = extractColors(tokenJson);

// ── Compute scale per breakpoint ───────────────────────────────────────────────
function parseClamp(value) {
  const m = value.match(/clamp\((\d+)px,\s*([\d.]+)vw,\s*(\d+)px\)/);
  if (m) return { min: parseInt(m[1]), vw: parseFloat(m[2]), max: parseInt(m[3]) };
  return null;
}

function resolveForWidth(value, width) {
  const clamp = parseClamp(value);
  if (clamp) return Math.round(Math.max(clamp.min, Math.min(width * clamp.vw / 100, clamp.max)));
  const px = parseInt(value);
  return isNaN(px) ? 16 : px;
}

// Use figma-variables.json (has clamp expressions) not the flattened tokens
const titleValue = tokenJson?.font?.size?.title?.value || "92px";
const h2Value = tokenJson?.font?.size?.h2?.value || "42px";

const scale = {};
for (const bp of workflow.breakpoints) {
  scale[bp.name] = {
    titlePx: resolveForWidth(titleValue, bp.width),
    h2Px: resolveForWidth(h2Value, bp.width),
    compact: bp.width <= 768,
  };
}

// ── Build screens array ────────────────────────────────────────────────────────
const screens = workflow.breakpoints.map((bp) => ({
  name: `Screen / ${bp.label}`,
  breakpoint: bp.name,
  width: bp.width,
}));

// ── Assemble payload ───────────────────────────────────────────────────────────
const payload = {
  project: pageContent.project || "Untitled",
  integration: workflow.integration,
  workflowVersion: workflow.workflowVersion,
  fonts: pageContent.fonts || { display: "Inter", body: "Inter", fallback: "Inter" },
  screens,
  scale,
  colors,
  tokens: flatTokens,
  tokenFrames: workflow.tokenFrames,
  sections: pageContent.sections || [],
};

// ── Read renderer and write code.js ────────────────────────────────────────────
const rendererPath = path.join(ROOT, "figma-plugins/studioflow-screens/renderer.js");
const outputPath = path.join(ROOT, "figma-plugins/studioflow-screens/code.js");

const renderer = fs.readFileSync(rendererPath, "utf8");
const output = "// Auto-generated by scripts/build-figma-plugin.mjs — do not edit directly\nvar PAYLOAD = " + JSON.stringify(payload, null, 2) + ";\n\n" + renderer;
fs.writeFileSync(outputPath, output, "utf8");

console.log("✓ Generated figma-plugins/studioflow-screens/code.js");
console.log(`  ${screens.length} screens, ${Object.keys(colors).length} colors, ${flatTokens.length} tokens, ${payload.sections.length} sections`);
console.log("  Next: open Figma → Plugins → Development → StudioFlow Screens → Run All");
